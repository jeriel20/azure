##########################################################################
# Script Name   :  bccslib5r2.ps1
# Version       :  9.5
# Creation Date :  15 October 2015
# Created By    :  Software Engineering Center
#               :  Aberdeen Proving Ground (APG), MD
# Prerequisites :  .NET FW 3.5, PowerShell 3.0
# Files         :  bccslib5r2.ps1   (this file)
# Paths         :  File must be located in C:\Scripts
##########################################################################
# Constants
##########################################################################

set-variable -name BCCSver    -value "2.0.1" -Option Constant
set-variable -name BCCSLibver -value "9.5" -Option Constant

##########################################################################
# Global Settings 
##########################################################################

$ProgressPreference = "SilentlyContinue"

##########################################################################
# Logging
##########################################################################

filter Write-Log()
{
  $logline = $BCCSver + " : " + (Get-Date).ToString('s') + " " + $_
  Out-File -filePath $logfile -append:$true -noClobber:$true -inputObject $logline
}

##########################################################################
#
#                            FUNCTIONS - UI
#
##########################################################################

##########################################################################
# Set-Console
# Usage   : Configures the PowerShell window color and title bar
# Receive : String ($software)
# Returns : $titlebar 

Function Set-Console ($software)
{

   	$scriptname = $MyInvocation.Scriptname
   	$pos = $scriptname.LastIndexOf("\")
   	$scriptname = $scriptname.Substring($pos+1)

   	$a = (Get-Host).UI.RawUI
   	$a.BackgroundColor = "Black"
   	$a.ForegroundColor = "White"

   	$titlebar  = " < $software >   |  "
   	$titlebar += "$Scriptname  |  "
   	$titlebar += "TSI v2  |  "
   	$titlebar += "$env:computername  |  "
	#If no domain connection exists, don't display it
   	if (($env:userdnsdomain).length -gt 0) { $titlebar += "$env:userdnsdomain  |  " }
   	$titlebar += "$env:username"

   	$a.WindowTitle = $titlebar

  	return $titlebar
}

##########################################################################
# ConvertTo-PlainText
# Usage   : Decrypts the text generated by "Read-Host -asSecureString"
# Receive : Encrypted string
# Returns : String in plain text 

Function ConvertTo-PlainText( [security.securestring]$secure ) 
{
	$marshal = [Runtime.InteropServices.Marshal] 
	$marshal::PtrToStringAuto( $marshal::SecureStringToBSTR($secure) ) 
}

##########################################################################
# PauseMessage
# Usage   : Provides ability to stop processing until a key is pressed
# Receive : String for Message
# Returns : {Empty} 

Function Pause ($PauseMessage="Press any key to continue...")
{
   Write-Host -NoNewline -ForegroundColor WHITE " $PauseMessage"
   $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
   Write-Host ""
}

##########################################################################
# get-Response
# Usage   : Prompts for input while providing a default answer so the user
#         : has the option of simply hitting <Enter>.
#         : If no default response is provided then it will continue to
#         : prompt for an answer (not accept a {blank} response)
# Receive : String for Message, String for Color, Optional Default Response
# Returns : String answer 

Function get-Response($PromptMessage,$txtColor="CYAN",$DefaultAnswer)
{
	#If the prompt message doesn't begin with a space, add one
	if (!$PromptMessage.StartsWith(" ")) { $PromptMessage = " " + $PromptMessage }
	
	#Prepare answer variable
	$answer = ""

	while($answer.length -eq 0)
	{
		#Display the prompt
		Write-Host $PromptMessage -ForegroundColor $txtColor -NoNewline

		#Display the default option if one has been provided
		if($DefaultAnswer.Length -gt 0)
		{
			Write-Host -ForegroundColor WHITE " [" -NoNewline
			Write-Host -ForegroundColor GREEN $DefaultAnswer -NoNewline
			Write-Host -ForegroundColor WHITE  "]" -NoNewline
		}

		Write-Host -ForegroundColor WHITE " : " -NoNewline

		$answer = Read-Host

		if($answer.length -eq 0)
		{
			if($DefaultAnswer.Length -gt 0)
			{
				$answer = $Defaultanswer
			}
		}
	}

	return $answer
}

##########################################################################
# get-IPv4Response
# Usage   : Prompts for input while providing a default answer so the user
#         : has the option of simply hitting <Enter>.
#         : If no default response is provided then it will continue to
#         : prompt for an answer (not accept a {blank} response or invalid IP)
# Receive : String for Message, String for Color, Optional Default Response
# Returns : String answer 

Function get-IPv4Response($PromptMessage,$Color="CYAN",$DefaultAnswer)
{
	#If the prompt message doesn't begin with a space, add one
	if (!$PromptMessage.StartsWith(" ")) { $PromptMessage = " " + $PromptMessage }
	
	#Prepare answer variable
	$answer = ""

	#Loop as long as there is no answer or an invalid answer
	while($answer.length -eq 0)
	{
		#Display the prompt
		Write-Host -ForegroundColor $Color "$PromptMessage" -NoNewline

		#If there is a default answer, display it
		if($DefaultAnswer.Length -gt 0)
		{
			Write-Host -ForegroundColor WHITE " [" -NoNewline
			Write-Host -ForegroundColor GREEN $DefaultAnswer -NoNewline
			Write-Host -ForegroundColor WHITE  "]" -NoNewline
		}

		#Input seperator
		Write-Host -ForegroundColor WHITE " : " -NoNewline

		#Get input from the user
		$answer = Read-Host

		#Is a blank answer provided?
		if($answer.length -eq 0)
		{
			#Is there a default?
			if($DefaultAnswer.Length -gt 0)
			{
				#Blank answer provided, so use default (it should not be invalid)
				$answer = $Defaultanswer
			}
		}
		else
		{
			#Answer is not blank, validate the IP
			$testresult = isValidIPv4Address $answer
			if ($testresult -eq $true)
			{
				return $answer
			}
			else
			{
				$answer = ""
				Write-Host " Invalid IP v4 address entered.  Please try again." -ForegroundColor Red
			}
		}
	}

	return $answer
}

##########################################################################
# get-LicenseACK
# Usage   : Displays the government license acknowledgement and prompts
#         : for acceptance 
# Receive : None
# Returns : String answer 

Function get-LicenseACK()
{

   $ack = ""
   $yn = "Y","y","N","n"
   
$lic=@"

  You acknowledge and  understand that the Virtual Machine (VM) software and 
  all software  included  with this  package  is  provided to you by Project 
  Manager Mission Command (PM MC), and requires the use and proper licensing  
  of  additional   software   owned  by   third   party  Original  Equipment 
  Manufacturers (OEMs). If  this software is not being used at the  specific  
  direction  of,  and  under  an  existing contract with, a PEO C3T Program  
  Management  Office,    Product  Management  Office   or  Product  Director  
  organization, or  another  Department of  Defense  organization within the 
  U.S. Government  currently  under OEM  license,  you  agree that you will 
  obtain  and  comply  with all OEM licenses  as  needed to install, run and 
  test  the  provided  VM software.  PM MC  accepts  no  responsibility  for 
  providing,  reselling, or  arranging  for the  purchase of these licenses.

"@   
   
   while(!($yn -contains $ack))
   {

      Clear-Host
   
      Write-Host -ForegroundColor YELLOW "`n LICENSE STATEMENT"
      Write-Host -ForegroundColor GRAY   " ============================================================================"
      Write-Host -ForegroundColor WHITE  $lic
      Write-Host -ForegroundColor GRAY   " ============================================================================"   
      Write-Host
   
      $ack = get-Response " Do You Acknowledge and Understand (Y/N)?" "CYAN"
      
   }
   
   return $ack

}

##########################################################################
# get-Password
# Usage   : Prompts for a password twice, compares the answers, and
#         : if they match, the result is returned
#         : If they do NOT match the user is reprompted
# Receive : String for Message, String for Color
# Returns : String answer in plain text 

Function get-Password($PromptMessage,$Color="CYAN",$Confirm="Y")
{
	#Set defaults to different values to ensure they do not match
	$a = "1"
	$b = "2"

	#If the prompt message doesn't begin with a space, add one
	if (!$PromptMessage.StartsWith(" ")) { $PromptMessage = " " + $PromptMessage }
	
	#Loop as long as the passwords do not match
	while($a -cne $b)
	{
		#Display the first prompt
		Write-Host -ForegroundColor $Color "$PromptMessage" -NoNewline
		Write-Host -ForegroundColor White " : " -NoNewline
		#Get the first password and convert it to plain text temporarily
		$PWD1 = Read-Host -asSecureString
		$a = ConvertTo-PlainText($PWD1)

		#Is the confirm option enabled?
		if($Confirm -eq "Y")
		{
			#Make sure password wasn't blank
			if ($a -ne "")
			{
				#Get confirmation password
				Write-Host -ForegroundColor $Color "$PromptMessage" -NoNewline
				Write-Host " [" -ForegroundColor White -NoNewline
				Write-Host -ForegroundColor "YELLOW" "CONFIRM" -NoNewline
				Write-Host "] : " -ForegroundColor White -NoNewline
				$PWD2 = Read-Host -asSecureString
				$b = ConvertTo-PlainText($PWD2)
			}
		}
		else #No confirmation
		{
			#Force both passwords to match instead of confirming
			$PWD2 = $PWD1
			$b = $a
		}

	#Ensure password isn't blank
	if($a -eq "" -or $b -eq "") 
	{
		Write-Host
		Write-Host " " -NoNewline
		Write-Warning "Password Cannot be BLANK - Please Try Again ..."
		Write-Host
		$a = "1"
		$b = "2"
     }
	 else #Not blank
	 {
	 	#Ensure passwords match
		if($a -cne $b) 
		{
			Write-Host
			Write-Host " " -NoNewline
			Write-Warning "`n Passwords Do Not Match - Please Try Again ..."
			Write-Host
		}
	 }

  }

  return $PWD2
}


##########################################################################
# show-PasswordWarning
# Usage   : Displays a warning about using commonly used passwords

Function show-PasswordWarning()
{
	Write-Host
	displayString "WARNING: The password you are about to enter MUST NOT be a commonly known password.  It must be at least 15 characters long and contain a mix of lower-case letters, upper-case letters, numbers, and special characters." "Yellow"
	Write-Host
}

##########################################################################
# get-Path
# Usage   : Prompts for input while providing a default path so the user
#         : has the option of simply hitting <Enter>.
#         : Tests the provided path and if invalid will reprompt
# Receive : String for Message, String for Color, Optional Default Response
# Returns : String answer

Function get-Path($promptMessage,$DefaultPath="",$pathColor="CYAN")
{
	#If the prompt message doesn't begin with a space, add one
	if (!$promptMessage.StartsWith(" ")) { $promptMessage = " $promptMessage" }
	
	$path = ""

	while(($path.Trim()).Length -eq 0)
	{
		Write-Host "$promptMessage " -ForegroundColor $pathColor -NoNewline
 
		If($DefaultPath.Length -gt 0)
		{
			Write-Host -ForegroundColor WHITE "[" -NoNewline
			Write-Host -ForegroundColor GREEN $DefaultPath -NoNewline
			Write-Host -ForegroundColor WHITE  "] " -NoNewline
		}

		Write-Host -ForegroundColor WHITE ": " -NoNewline
		
		$path = Read-Host

		If($path.length -eq 0)
		{
			If($DefaultPath.Length -gt 0)
			{
				$path = $DefaultPath
			}
		}

		if($path.length -gt 0)
		{
			if(!(test-path "$path"))
			{
				Write-Host
				displayString "The specified path does not exist.  Please Try Again ..." "YELLOW"
				Write-Host
				$path = ""
			}
		}
	}
	
	#Return the valid path
	return $path
}

##########################################################################
# displayActionList
# Usage   : Displays an action list such as requirements or process list
# Receive : String for the title, String (array) for the list of actions
# Returns : Nothing
Function displayActionList($reqTitle,$reqList)
{
	#Write the requirements header
	Write-Host -ForegroundColor YELLOW  " $reqTitle"
	
	#Write a line under the requirements
	Write-Host " " -NoNewline
	for($i = 0; $i -lt $reqTitle.Length; $i++)
	{
		Write-Host "-" -NoNewline -ForegroundColor Gray
	}
	
	#Display each requirement from the $reqList array that was passed in
	Write-Host
	foreach($thisReq in $reqList)
	{
		Write-Host " » " -NoNewline -ForegroundColor Yellow
		Write-Host "$thisReq" -ForegroundColor Gray
	}
	
	#Finish up
	Write-Host
}

##########################################################################
# displayString
# Usage   : Displays a string formatted to fit within the 80 character
#			window width limit
# Receive : String for Message, String for Color of text
# Returns : Nothing
Function displayString($msg,$color="WHITE")
{
	$length=$host.UI.RawUI.WindowSize.Width
	
	#Trim leading and trailing spaces
	$msg = $msg.Trim()
	
	#Begin looping through the string until it's empty
	while ($msg.Length -gt 0)
	{
		#Is the string greater than the width of the window (-2)?
		if ($msg.Length -gt ($length - 2))
		{
			#If the prompt message doesn't begin with a space, add one
			if (!$msg.StartsWith(" ")) { $msg = " $msg" }
			#Get the first block of characters of the string (window width - 1)
			$tempStr = $msg.Substring(0,($length - 1))
			#Get the last space in the string
			$lastSpacePos = $tempStr.LastIndexOf(" ")
			#Display this line
			Write-Host ($msg.Substring(0, $lastSpacePos)) -ForegroundColor $color
			#Trim the displayed characters out of the $msg
			$msg = $msg.Substring($lastSpacePos + 1).Trim()
		}
		else
		{
			#Not greater than the width of the window, just display it
			Write-Host " $msg" -ForegroundColor $color
			$msg = ""
		}
	}
}

##########################################################################
# displayMessage
# Usage   : Appends spacer characters characters to end of a text string 
# Receive : String for Message, String for Color of text
# Returns : Nothing
Function displayMessage($msg,$color="CYAN")
{
	#Set the default length and spacer character (no longer optional)
	$length=$host.UI.RawUI.WindowSize.Width
	$spacer="."
	
	#Make sure the message begins with a space
	if (!$msg.Substring(0,1).Contains(" ")) { $msg = " " + $msg }
	
	#Make sure the message ends with a space
	if (!$msg.Substring($msg.length - 1).Contains(" ")) { $msg = $msg + " " }
	
	#If the provided message is greater than the allowed length, shorten it.
	If($msg.length -gt $length) { $msg = $msg.substring(0,$length - 15) }
	
	#Display the message
	Write-Host -ForegroundColor $color "$msg" -NoNewline
	
	#Figure out the number of spacers needed (subtract 13 for the [ WORKING ] msg)
	$numspacers = ($length - 13) - $msg.length
	
	#Display the spacers
	for($i=0; $i -lt $numspacers; $i++)
	{
		Write-Host -ForegroundColor WHITE $spacer -NoNewline
	}
	
	#Display the WORKING message
	Write-Host -ForegroundColor WHITE  " [ "     -NoNewline
	Write-Host -ForegroundColor GRAY "WORKING" -NoNewline
	Write-Host -ForegroundColor WHITE  " ] "     -NoNewline
}

##########################################################################
# displayStatus
# Usage   : Displays Message Status 
# Receive : String for Message, String for Color
# Returns : Nothing 
# Values  : 0 = OK, Green
#         : 1 = WARNING, Yellow
#         : 2 = ERROR, Red
#         : 3 - EXISTS, YELLOW
#         : 4 - NA, GREEN
#         : 5 - Installed, GRAY
#         : 6 - Running, GREEN
#         : 7 - YES, GREEN
#         : 8 - NO, YELLOW
#         : Any other value same as 0

Function displayStatus($status=0)
{
	#Set the default length and spacer character (no longer optional)
	$length=$host.UI.RawUI.WindowSize.Width
	$spacer="."
	
	#Create arrays for text and color
	$arrText = "OK","WARNING","ERROR","EXISTS","NA","INSTALLED","RUNNING","YES","NO"
	$arrColor = "GREEN","YELLOW","RED","YELLOW","GRAY","GRAY","GREEN","GREEN","YELLOW"
	
	#Set the text and color to be displayed based on the $status provided
	$statustext = $arrText[$status]
	$statuscolor = $arrColor[$status]

	#Move the cursor position based on the status message
	#  (15 is the longest move right now with message INSTALLED)
	$cursorPos = $Host.UI.RawUI.CursorPosition
	$cursorPos.Y = $cursorPos.Y - 1
	$cursorPos.X = $length - 15
	$Host.UI.RawUI.CursorPosition = $cursorPos
	
	#Do we need to draw any spacers?
	if ($statustext.Length -lt 9)
	{
		#Calculate spacers needed
		$numspacers = 15 - $statustext.Length - 6
		
		#Draw the required spacers
		for($i=0; $i -lt $numspacers; $i++)
		{
			Write-Host -ForegroundColor WHITE $spacer -NoNewline
		}
	}

	Write-Host -ForegroundColor WHITE  " [ "   -NoNewline
	Write-Host -ForegroundColor $statuscolor $statustext -NoNewline
    Write-Host -ForegroundColor WHITE  " ]" 
	Write-Host
}

##########################################################################
# displayMainHeader
# Usage   : Prints the specified title as a primary header to the screen
# Receive : (String) Message, (String) Color of text, (String) Color of thick bar
# Returns : Nothing
# Example :	This Is A Script
#			================
Function displayMainHeader($hdrTitle,$txtColor="YELLOW",$barColor="WHITE")
{
	#First, clear the screen and add a blank line
	Clear-Host
	Write-Host
	
	#If the title doesn't begin with a space, add one
	if (!$hdrTitle.Substring(0,1).Contains(" ")) { $hdrTitle = " " + $hdrTitle }
	
	#Print the title
	displayString $hdrTitle $txtColor
	
	#Print the thick bar under the title
	displayLine "="
	Write-Host
}

##########################################################################
# displaySubHeader
# Usage   : Prints the specified title as a sub-header to the screen 
# Receive : (String) Message, (String) Color of text, (String) Color of thin bar
# Returns : Nothing
# Example :	This Is A Sub-Header
#			--------------------
Function displaySubHeader($hdrTitle,$txtColor="WHITE",$barColor="GRAY")
{
	#If the title doesn't begin with a space, add one
	if (!$hdrTitle.Substring(0,1).Contains(" ")) { $hdrTitle = " " + $hdrTitle }
	
	#Print the title
	displayString $hdrTitle $txtColor
	
	#Print a thin bar of the same length
	Write-Host " " -NoNewline
	for($i = 0; $i -lt $hdrTitle.Length - 1; $i++)
	{
		Write-Host "-" -NoNewline -ForegroundColor $barColor
	}
	Write-Host
}

##########################################################################
# displayLine
# Usage   : Displays a line that equals the width of the window with
#           the specified character repeated
# Receive : String for the character to display, String for the color
# Returns : Nothing
Function displayLine($lineChar="-",$lineColor="White")
{
	#Get the current width of the window and subtract 2 from it to leave
	#  blank spaces at the beginning and end of the line
	$length=$host.UI.RawUI.WindowSize.Width - 2
	
	#Start the line with a empty character
	Write-Host " " -NoNewline
	
	#Loop for the width of the window (length of line)
	for($i = 0; $i -lt $length; $i++)
	{
		#Display the character
		Write-Host $lineChar -ForegroundColor $lineColor -NoNewline
	}
	
	#End the line
	Write-Host
}

##########################################################################
# setWindowSize
# Usage   : Sets the PowerShell window width and height
# Receive : Int for Width, Int for Height
# Returns : Nothing
Function setWindowSize($windowWidth=100,$windowHeight=50)
{
	#Suppress errors and warnings
	$ErrorActionPreference = "SilentlyContinue"
	$WarningPreference = "SilentlyContinue"
	
	#Get the current buffer and WindowSize
	$buffer = $Host.UI.RawUI.BufferSize
	$windowsize = $Host.UI.RawUI.WindowSize
	
	#Set the buffer width to the windowWidth
	$buffer.Width = $windowWidth
	
	#Set the width and height of the window to the specified values
	$windowsize.Width = $windowWidth
	$windowsize.Height = $windowHeight
	#Set the buffer size
	$Host.UI.RawUI.BufferSize = $buffer
	#Set the window size
	$Host.UI.RawUI.WindowSize = $windowsize
	$Host.UI.RawUI.BufferSize = $buffer
	#And the window size one more time (allows for sizing up)
	$Host.UI.RawUI.WindowSize = $windowsize
}


##########################################################################
#
#                          FUNCTIONS - SYSTEM
#
##########################################################################

##########################################################################
# get-Framework-Versions
# DEPRECATED, SHOULD NOT BE USED ANY MORE.  USE: get-WindowsFeature instead
# Usage   : Returns installed .NET Framework Versions
# Recieve : {Empty}
# Returns : List of Installed Frameworks

Function Get-Framework-Versions()
{
    $installedFrameworks = @()
    if(Test-Key "HKLM:\Software\Microsoft\.NETFramework\Policy\v1.0" "3705") { $installedFrameworks += "1.0" }
    if(Test-Key "HKLM:\Software\Microsoft\NET Framework Setup\NDP\v1.1.4322" "Install") { $installedFrameworks += "1.1" }
    if(Test-Key "HKLM:\Software\Microsoft\NET Framework Setup\NDP\v2.0.50727" "Install") { $installedFrameworks += "2.0" }
    if(Test-Key "HKLM:\Software\Microsoft\NET Framework Setup\NDP\v3.0\Setup" "InstallSuccess") { $installedFrameworks += "3.0" }
    if(Test-Key "HKLM:\Software\Microsoft\NET Framework Setup\NDP\v3.5" "Install") { $installedFrameworks += "3.5" }
    if(Test-Key "HKLM:\Software\Microsoft\NET Framework Setup\NDP\v4\Client" "Install") { $installedFrameworks += "4.0c" }
    if(Test-Key "HKLM:\Software\Microsoft\NET Framework Setup\NDP\v4\Full" "Install") { $installedFrameworks += "4.0" }   
     
    return $installedFrameworks
}

##########################################################################
# test-Key
# Usage   : Verifies the existence of a registry key
# Receive : Path to key, key
# Returns : True or False
 
Function Test-Key([string]$path, [string]$key)
{
    if(!(Test-Path $path)) { return $false }
    if ((Get-ItemProperty $path).$key -eq $null) { return $false }
    return $true
}

##########################################################################
# disable-PubCheck
# Usage   : Set registry key property "State" to remove "Check for Publisher's certificate revocation" in IE
#         : This will temporarily allow software installation (key resets after ~45 minutes)
# Receive : {Empty}
# Return  : True (if property does not exist still return TRUE)

Function disable-PubCheck()
{
   $state = get-itemproperty -path 'HKCU:\Software\Microsoft\Windows\CurrentVersion\WinTrust\Trust Providers\Software Publishing' -name "State" -EA SilentlyContinue
   if( $state -ne $NULL)
   {
      set-ItemProperty 'HKCU:\Software\Microsoft\Windows\CurrentVersion\WinTrust\Trust Providers\Software Publishing' -Name "State" -value "146432" -EA SilentlyContinue -WA SilentlyContinue
   }
   return $true
}

##########################################################################
# delete-PubCheck
# Usage   : Delete registry key property "State" to remove "Check for Publisher's certificate revocation" in IE
#         : This will temporarily allow software installation (property is recreated after a reboot)
# Receive : {Empty}
# Return  : True (if property does not exist still return TRUE)

Function delete-PubCheck()
{
   $state = get-itemproperty -path 'HKCU:\Software\Microsoft\Windows\CurrentVersion\WinTrust\Trust Providers\Software Publishing' -name "State" -EA SilentlyContinue
   if( $state -ne $NULL)
   {
      remove-itemproperty -path 'HKCU:\Software\Microsoft\Windows\CurrentVersion\WinTrust\Trust Providers\Software Publishing' -name State -EA SilentlyContinue
   }
   return $true
}

##########################################################################
# get-CDROM
# Usage   : Finds CDROM devices and returns the first one it discovers
# Receive : {Empty}
# Returns : String answer 

Function get-CDROM()
{

   $CD = ""
 
   $drives = Get-WmiObject -Class Win32_CDROMDrive

   If($drives.Count -eq $null)
   {
     $CD = $drives.Drive
   }
   else
   {
     $CD = $drives[0].Drive
   }

  return $CD

}

##########################################################################
# get-2nd_HD
# Usage   : Checks for additional hard drives, other than System Drive
# Receive : {Empty}
# Returns : String letter of LAST available hard drive

Function get-2nd_HD()
{

   $2HD = ""
 
   $hdrives = Get-WmiObject -Class Win32_logicaldisk

   foreach ($drive in $hdrives) 
   {
      if(($drive.drivetype -eq 3) -and ($drive.DeviceID -ne $env:SystemDrive))
      {
         $2HD = $drive.DeviceID
      }
   }   

  return $2HD

}

##########################################################################
# get-DiskSize
# Usage   : Retrieves total size of disk
# Receive : Device ID
# Returns : Exact Disk Size or 0 if no disk 

Function get-DiskSize($diskID)
{

   $diskSize = 0
 
   $hdrives = Get-WmiObject -Class Win32_logicaldisk

   foreach ($drive in $hdrives) 
   {
      if($drive.DeviceID -eq $diskID)
      {
         $diskSize = $drive.Size
      }
   }   

  return $diskSize

}

##########################################################################
# get-OS
# Usage   : Retrieves the OS Version
# Receive : {Empty}
# Returns : W2K8R2SP1, W2K8, or Other 

Function get-OS()
{
   # This is for Windows 8.1/2012 R2
   # (Get-CimInstance Win32_OperatingSystem).Version

   $QueryOS = Gwmi Win32_OperatingSystem
   $QueryOS = $QueryOS.Version 

   If     ($QueryOS.contains("6.1.7601")) { $OS = "W2K8R2SP1" }
   elseif ($QueryOS.contains("6.1"))      { $OS = "W2K8R2"    }
   elseif ($QueryOS.contains("6.0"))      { $OS = "W2K8"      }
   elseif ($QueryOS.contains("6.2.9200")) { $OS = "W2012"     }
   elseif ($QueryOS.contains("6.3.9600")) { $OS = "W2012R2"   }
   else                                   { $OS = "Other"     }

   return $OS
}

##########################################################################
# check-domainMember
# Usage   : Checks for domain membership
# Receive : {Empty}
# Returns : TRUE or FALSE 

Function check-domainMember()
{
  $isMember = (gwmi win32_computersystem).partofdomain
  return $isMember
}

##########################################################################
# clear-NICsettings
# Usage   : Removes NIC settings and resets to DHCP
# Receive : INT ifidx (Interface Index Number)
# Returns : TRUE or FALSE 

Function clear-NICsettings($ifidx)
{

   Remove-NetIPAddress -InterfaceIndex $ifidx -AddressFamily IPv4 -Confirm:$false -ErrorAction SilentlyContinue
   Remove-NetRoute     -InterfaceIndex $ifidx -DestinationPrefix 0.0.0.0/0 -Confirm:$false -ErrorAction SilentlyContinue
   Set-NetIPInterface  -InterfaceIndex $ifidx -AddressFamily IPv4 -Dhcp Enabled
   Set-DnsClientServerAddress –InterfaceIndex $ifidx -ResetServerAddresses
   
   Return $true

}

##########################################################################
# get-PrefixLength
# Usage   : Calculates the PrefixLength based on a full netmask setting
# Receive : STRING netMaskSet
# Returns : Mask Length (INT)

Function get-PrefixLength($netMask="255.255.255.0")
{

   $arrNetMasks  = "255.255.255.255","255.255.255.254","255.255.255.252","255.255.255.248","255.255.255.240","255.255.255.224","255.255.255.192","255.255.255.128","255.255.255.0"
   $arrNetMasks += "255.255.254.0","255.255.252.0","255.255.248.0","255.255.240.0","255.255.224.0","255.255.192.0","255.255.128.0","255.255.0.0"
   $arrNetMasks += "255.254.0.0","255.252.0.0","255.248.0.0","255.240.0.0","255.224.0.0","255.192.0.0","255.128.0.0","255.0.0.0"
   
   $pos = [array]::indexOf($arrNetMasks,$netMask)
   
   if($pos -gt -1)
   {
      $maskLen = 32 - $pos
   }
   else
   {
      $maskLen = $pos
   }
   
   Return $maskLen

}

##########################################################################
# get-PingStatus
# Usage   : Checks to see if the specified host is reachable on the network
# Receive : String hostname, INT Number of Attempts
# Returns : TRUE or FALSE 
# WARNING - This function is deprecated - use test-connection

Function get-PingStatus($hostname)
{
   $pstatus = Test-Connection -ComputerName "$hostname" -quiet
   return $pstatus
}

##########################################################################
# reset-IIS
# Usage   : Resets IIS then checks to make sure it restarted (10 retries)
# Receive : {none}
# Returns : TRUE or FALSE

Function reset-IIS
{
   & iisreset /noforce | out-null

   $i = 1
   while ($i -le 10) 
   { 
      $w3svc = get-service -name w3svc

      if($w3svc.status -eq "Stopped") 
      { 
          Start-Service w3svc 
          $i++
      }
      else
      {
          return $TRUE
      }
   }

   return $FALSE
}



##########################################################################
#
#                       FUNCTIONS - ACCOUNTS
#
##########################################################################

##########################################################################
# get-default_Account
# Usage   : Searches Active Directory for accounts "tagged" with a value
#         : in the "Department" field of the account, then returns account name
# Receive : String to search for in Department Field, Default Account if none found
# Returns : String Domain name \ Account Name

Function get-default_Account($deptValue, $defaultResult)
{

   $dom = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
   $root = $dom.GetDirectoryEntry()
   $search = [System.DirectoryServices.DirectorySearcher]$root

   $search.Filter = "(department=$deptvalue)"
   $result = $search.FindOne()

   if($result -eq $null)
   {
      $acctResult = $env:userdomain + "\" + $defaultResult
   }
   else
   {
      $acctResult = $env:userdomain + "\" + $result.properties.samaccountname
   }

   return $acctResult

}

##########################################################################
# get-AccountName
# Usage   : Parses the domain name from the beginning of a string
# Receive : String account in form of "domain\account"
# Returns : String answer with "domain\" section removed

Function get-AccountName($long_acct)
{

   $pos = 0
   $pos = $long_acct.IndexOf("\")

   if($pos -eq 0)
   {
      $acctOnly = $long_acct
   }
   else
   {
      $acctOnly = $long_acct.substring($pos+1)
   }

   $returnanswer = $acctOnly
   return $returnanswer = $acctOnly

}

##########################################################################
# get-GroupMembership
# Usage   : Checks for Account in a Specific Domain Group
# Receive : Domain Account Name, Security Group
# Returns : 1 - True, 0 - False

Function get-GroupMembership($acct,$grp)
{
   $dom = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
   $root = $dom.GetDirectoryEntry()
   $search = [System.DirectoryServices.DirectorySearcher]$root

   $search.Filter = "(sAMAccountName=$acct)"
   $result = $search.FindOne()

   if($result.properties.memberof -like "*$grp*") { $found = 1 } else { $found = 0 }

   return $found

}

##########################################################################
# check_Domain_Group
# Usage   : Checks for existence of a Domain Group
# Receive : Domain Security Group
# Returns : 0 - False; 1 - True

function check_Domain_Group($groupName)
{
	$grps = Get-WmiObject win32_group | where {$_.domain -eq $env:userdomain}
	$filter = $grps | where {$_.name -match $groupName}
	if ($filter -eq $null)	{  return 0  }
	else {	return 1  }
}

##########################################################################
# check_Domain_User
# Usage   : Checks for existence of a Domain User
# Receive : Domain Username
# Returns : 0 - False; 1 - True

function check_Domain_User($userName)
{
	$grps = Get-WmiObject win32_useraccount | where {$_.domain -eq $env:userdomain}
	$filter = $grps | where {$_.name -match $userName}
	if ($filter -eq $null)	{  return 0  }
	else {	return 1  }
}



##########################################################################
#
#                          FUNCTIONS - NETWORK
#
##########################################################################

##########################################################################
# get-DNSip
# Usage   : Finds the IP Address assigned to an Enabled NIC
# Receive : {empty}
# Returns : String IP Address

Function get-DNSip()
{

   $strComputer = "."

   $NICItems = get-wmiobject -class "Win32_NetworkAdapterConfiguration" -computername $strComputer | Where{$_.IpEnabled -Match "True"}

   foreach ($NIC in $NICItems)
   {
      $dnsipaddress = $NIC.DNSServerSearchOrder
      if ($dnsipaddress) { break }
   }
   
   if($dnsipaddress.count)
   {
      $ip = $dnsipaddress[0]
   }
   else
   {
      $ip = $dnsipaddress
   }

   return $ip

}

##########################################################################
# get-Localip
# Usage   : Finds the IPv4 Address assigned to this machine
# Receive : {empty}
# Returns : String IP Address

Function get-Localip()
{

   $strComputer = "."

   $NICItems = get-wmiobject -class "Win32_NetworkAdapterConfiguration" -computername $strComputer

   foreach ($thisItem in $NICItems)
   {
	$dnsipaddress = $thisItem.IPAddress

	if ($dnsipaddress)
	{
		if ($dnsipaddress.count -eq 1)
		{
			return $dnsipaddress
		}
		else
		{
			return $dnsipaddress[0]
		}
	}
   }

   return $dnsipaddress
}

##########################################################################
# isValidIPv4Address
# Usage   : Ensures a specified IP v4 address is in a valid format
# Receive : IP v4 Address string
# Returns : Boolean result
Function isValidIPv4Address($ipAddr)
{
	#Prepare pattern of allowable characters (numbers and dot)
	$pattern= "^[0-9\.]+$"
	
	#Does the address contain only allowable characters?
	if ($ipAddr -match $pattern)
	{
		#Break apart the IP
		$splitIP = $ipAddr.Split(".")
		
		#Make sure there are exactly 4 octets
		if ($splitIP.Count -ne 4) { return $false }
		
		#Check each octet to make sure it is proper length
		foreach ($thisOctet in $splitIP)
		{
			if ($thisOctet.Length -gt 3) { return $false }
			if ($thisOctet.Length -eq 0) { return $false }
		}
		
		#Everything looks good
		return $true
	}
	else
	{
		return $false
	}
}



##########################################################################
#
#                           FUNCTIONS - SQL
#
##########################################################################

##########################################################################
# New-SQLconnection
# Usage   : Creates a Connection to SQL Server 2005
# Receive : SQL Server name, Database, Connection Name 
# Returns : Connection Handle

function New-SQLconnection {
    Param ([string]$server,
        [string]$database = "master",
        [string]$connectionName = $ScriptName)
    if (test-path variable:\conn) {
        $conn.close()
    } else {
        $conn = new-object ('System.Data.SqlClient.SqlConnection')
    }
    $connString = "Server=$server;Integrated Security=SSPI;Database=$database;Application Name=$connectionName"
    $conn.ConnectionString = $connString
    $conn.StatisticsEnabled = $true
    $conn.Open()
    $conn
}

##########################################################################
# Query-SQL
# Usage   : Executes a T-SQL query and returns result table
# Receive : Query string, Connection Handle, Timeout (optional)
# Returns : Query Result

function Query-SQL {
    Param ($query, $conn, [int]$CommandTimeout = 30)
    $sqlCmd = New-Object System.Data.SqlClient.SqlCommand
    $sqlCmd.CommandTimeout = $CommandTimeout
    $sqlCmd.CommandText = $query
    $sqlCmd.Connection = $conn
    $Rset = $sqlCmd.ExecuteReader()
    if ($? -eq $false) {
        Close-SQLquery $rset
        [int]$rset = -1
    }
    if ($Rset.hasrows -eq $false) {
        Close-SQLquery $rset
        [string]$rset = ""
    }
    ,$Rset ## The comma is used to create an outer array, which PS strips off automatically when returning the $Rset
}

##########################################################################
# NonQuery-SQL
# Usage   : Executes a non-Query SQL Commands (i.e. Stored Procedures)
# Receive : Query, Connection Handle, Timeout (optional)
# Returns : Success or Failure

function NonQuery-SQL {
    Param ($query, $conn, $CommandTimeout = 30)
    $sqlCmd = New-Object System.Data.SqlClient.SqlCommand
    $sqlCmd.CommandTimeout = $CommandTimeout
    $sqlCmd.CommandText = $query
    $sqlCmd.Connection = $conn
    $RowsAffected = $sqlCmd.ExecuteNonQuery()
    if ($? -eq $false) {
        $RowsAffected = -2
    }
    $RowsAffected
}

##########################################################################
# Close-SQLquery
# Usage   : Closes the query and sets to NULL
# Receive : Query
# Returns : {none}

function Close-SQLquery {
    Param ($query)
    $query.close()
    $query = $null
}

##########################################################################
# Remove-SQLconnection
# Usage   : Releases the connection handle to SQL Server 2005
# Receive : Connection Handle
# Returns : {none}

function Remove-SQLconnection {
    Param ($connection)
    $connection.close()
    $connection = $null
}

##########################################################################
